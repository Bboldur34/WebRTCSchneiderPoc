/**
 * Minified by jsDelivr using Terser v5.3.5.
 * Original file: /npm/mediasoup-client@3.6.34/lib/handlers/Safari11.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(e,t,a,r){void 0===r&&(r=a),Object.defineProperty(e,r,{enumerable:!0,get:function(){return t[a]}})}:function(e,t,a,r){void 0===r&&(r=a),e[r]=t[a]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),__importStar=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var a in e)"default"!==a&&Object.hasOwnProperty.call(e,a)&&__createBinding(t,e,a);return __setModuleDefault(t,e),t};Object.defineProperty(exports,"__esModule",{value:!0}),exports.Safari11=void 0;const sdpTransform=__importStar(require("sdp-transform")),Logger_1=require("../Logger"),utils=__importStar(require("../utils")),ortc=__importStar(require("../ortc")),sdpCommonUtils=__importStar(require("./sdp/commonUtils")),sdpPlanBUtils=__importStar(require("./sdp/planBUtils")),HandlerInterface_1=require("./HandlerInterface"),RemoteSdp_1=require("./sdp/RemoteSdp"),logger=new Logger_1.Logger("Safari11"),SCTP_NUM_STREAMS={OS:1024,MIS:1024};class Safari11 extends HandlerInterface_1.HandlerInterface{constructor(){super(),this._sendStream=new MediaStream,this._mapSendLocalIdRtpSender=new Map,this._nextSendLocalId=0,this._mapRecvLocalIdInfo=new Map,this._hasDataChannelMediaSection=!1,this._nextSendSctpStreamId=0,this._transportReady=!1}static createFactory(){return()=>new Safari11}get name(){return"Safari11"}close(){if(logger.debug("close()"),this._pc)try{this._pc.close()}catch(e){}}async getNativeRtpCapabilities(){logger.debug("getNativeRtpCapabilities()");const e=new RTCPeerConnection({iceServers:[],iceTransportPolicy:"all",bundlePolicy:"max-bundle",rtcpMuxPolicy:"require",sdpSemantics:"plan-b"});try{const t=await e.createOffer({offerToReceiveAudio:!0,offerToReceiveVideo:!0});try{e.close()}catch(e){}const a=sdpTransform.parse(t.sdp);return sdpCommonUtils.extractRtpCapabilities({sdpObject:a})}catch(t){try{e.close()}catch(e){}throw t}}async getNativeSctpCapabilities(){return logger.debug("getNativeSctpCapabilities()"),{numStreams:SCTP_NUM_STREAMS}}run({direction:e,iceParameters:t,iceCandidates:a,dtlsParameters:r,sctpParameters:s,iceServers:i,iceTransportPolicy:n,additionalSettings:c,proprietaryConstraints:o,extendedRtpCapabilities:d}){logger.debug("run()"),this._direction=e,this._remoteSdp=new RemoteSdp_1.RemoteSdp({iceParameters:t,iceCandidates:a,dtlsParameters:r,sctpParameters:s,planB:!0}),this._sendingRtpParametersByKind={audio:ortc.getSendingRtpParameters("audio",d),video:ortc.getSendingRtpParameters("video",d)},this._sendingRemoteRtpParametersByKind={audio:ortc.getSendingRemoteRtpParameters("audio",d),video:ortc.getSendingRemoteRtpParameters("video",d)},this._pc=new RTCPeerConnection(Object.assign({iceServers:i||[],iceTransportPolicy:n||"all",bundlePolicy:"max-bundle",rtcpMuxPolicy:"require"},c),o),this._pc.addEventListener("iceconnectionstatechange",(()=>{switch(this._pc.iceConnectionState){case"checking":this.emit("@connectionstatechange","connecting");break;case"connected":case"completed":this.emit("@connectionstatechange","connected");break;case"failed":this.emit("@connectionstatechange","failed");break;case"disconnected":this.emit("@connectionstatechange","disconnected");break;case"closed":this.emit("@connectionstatechange","closed")}}))}async updateIceServers(e){logger.debug("updateIceServers()");const t=this._pc.getConfiguration();t.iceServers=e,this._pc.setConfiguration(t)}async restartIce(e){if(logger.debug("restartIce()"),this._remoteSdp.updateIceParameters(e),this._transportReady)if("send"===this._direction){const e=await this._pc.createOffer({iceRestart:!0});logger.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]",e),await this._pc.setLocalDescription(e);const t={type:"answer",sdp:this._remoteSdp.getSdp()};logger.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]",t),await this._pc.setRemoteDescription(t)}else{const e={type:"offer",sdp:this._remoteSdp.getSdp()};logger.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]",e),await this._pc.setRemoteDescription(e);const t=await this._pc.createAnswer();logger.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]",t),await this._pc.setLocalDescription(t)}}async getTransportStats(){return this._pc.getStats()}async send({track:e,encodings:t,codecOptions:a,codec:r}){this._assertSendDirection(),logger.debug("send() [kind:%s, track.id:%s]",e.kind,e.id),r&&logger.warn("send() | codec selection is not available in %s handler",this.name),this._sendStream.addTrack(e),this._pc.addTrack(e,this._sendStream);let s,i=await this._pc.createOffer(),n=sdpTransform.parse(i.sdp);const c=utils.clone(this._sendingRtpParametersByKind[e.kind],{});c.codecs=ortc.reduceCodecs(c.codecs);const o=utils.clone(this._sendingRemoteRtpParametersByKind[e.kind],{});if(o.codecs=ortc.reduceCodecs(o.codecs),this._transportReady||await this._setupTransport({localDtlsRole:"server",localSdpObject:n}),"video"===e.kind&&t&&t.length>1&&(logger.debug("send() | enabling simulcast"),n=sdpTransform.parse(i.sdp),s=n.media.find((e=>"video"===e.type)),sdpPlanBUtils.addLegacySimulcast({offerMediaObject:s,track:e,numStreams:t.length}),i={type:"offer",sdp:sdpTransform.write(n)}),logger.debug("send() | calling pc.setLocalDescription() [offer:%o]",i),await this._pc.setLocalDescription(i),n=sdpTransform.parse(this._pc.localDescription.sdp),s=n.media.find((t=>t.type===e.kind)),c.rtcp.cname=sdpCommonUtils.getCname({offerMediaObject:s}),c.encodings=sdpPlanBUtils.getRtpEncodings({offerMediaObject:s,track:e}),t)for(let e=0;e<c.encodings.length;++e)t[e]&&Object.assign(c.encodings[e],t[e]);if(c.encodings.length>1&&"video/vp8"===c.codecs[0].mimeType.toLowerCase())for(const e of c.encodings)e.scalabilityMode="S1T3";this._remoteSdp.send({offerMediaObject:s,offerRtpParameters:c,answerRtpParameters:o,codecOptions:a});const d={type:"answer",sdp:this._remoteSdp.getSdp()};logger.debug("send() | calling pc.setRemoteDescription() [answer:%o]",d),await this._pc.setRemoteDescription(d);const p=String(this._nextSendLocalId);this._nextSendLocalId++;const l=this._pc.getSenders().find((t=>t.track===e));return this._mapSendLocalIdRtpSender.set(p,l),{localId:p,rtpParameters:c,rtpSender:l}}async stopSending(e){this._assertSendDirection();const t=this._mapSendLocalIdRtpSender.get(e);if(!t)throw new Error("associated RTCRtpSender not found");t.track&&this._sendStream.removeTrack(t.track),this._mapSendLocalIdRtpSender.delete(e);const a=await this._pc.createOffer();logger.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]",a);try{await this._pc.setLocalDescription(a)}catch(e){if(0===this._sendStream.getTracks().length)return void logger.warn("stopSending() | ignoring expected error due no sending tracks: %s",e.toString());throw e}if("stable"===this._pc.signalingState)return;const r={type:"answer",sdp:this._remoteSdp.getSdp()};logger.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]",r),await this._pc.setRemoteDescription(r)}async replaceTrack(e,t){this._assertSendDirection(),t?logger.debug("replaceTrack() [localId:%s, track.id:%s]",e,t.id):logger.debug("replaceTrack() [localId:%s, no track]",e);const a=this._mapSendLocalIdRtpSender.get(e);if(!a)throw new Error("associated RTCRtpSender not found");const r=a.track;await a.replaceTrack(t),r&&this._sendStream.removeTrack(r),t&&this._sendStream.addTrack(t)}async setMaxSpatialLayer(e,t){this._assertSendDirection(),logger.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]",e,t);const a=this._mapSendLocalIdRtpSender.get(e);if(!a)throw new Error("associated RTCRtpSender not found");const r=a.getParameters();r.encodings.forEach(((e,a)=>{e.active=a<=t})),await a.setParameters(r)}async setRtpEncodingParameters(e,t){this._assertSendDirection(),logger.debug("setRtpEncodingParameters() [localId:%s, params:%o]",e,t);const a=this._mapSendLocalIdRtpSender.get(e);if(!a)throw new Error("associated RTCRtpSender not found");const r=a.getParameters();r.encodings.forEach(((e,a)=>{r.encodings[a]=Object.assign(Object.assign({},e),t)})),await a.setParameters(r)}async getSenderStats(e){this._assertSendDirection();const t=this._mapSendLocalIdRtpSender.get(e);if(!t)throw new Error("associated RTCRtpSender not found");return t.getStats()}async sendDataChannel({ordered:e,maxPacketLifeTime:t,maxRetransmits:a,label:r,protocol:s}){this._assertSendDirection();const i={negotiated:!0,id:this._nextSendSctpStreamId,ordered:e,maxPacketLifeTime:t,maxRetransmits:a,protocol:s};logger.debug("sendDataChannel() [options:%o]",i);const n=this._pc.createDataChannel(r,i);if(this._nextSendSctpStreamId=++this._nextSendSctpStreamId%SCTP_NUM_STREAMS.MIS,!this._hasDataChannelMediaSection){const e=await this._pc.createOffer(),t=sdpTransform.parse(e.sdp),a=t.media.find((e=>"application"===e.type));this._transportReady||await this._setupTransport({localDtlsRole:"server",localSdpObject:t}),logger.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]",e),await this._pc.setLocalDescription(e),this._remoteSdp.sendSctpAssociation({offerMediaObject:a});const r={type:"answer",sdp:this._remoteSdp.getSdp()};logger.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]",r),await this._pc.setRemoteDescription(r),this._hasDataChannelMediaSection=!0}return{dataChannel:n,sctpStreamParameters:{streamId:i.id,ordered:i.ordered,maxPacketLifeTime:i.maxPacketLifeTime,maxRetransmits:i.maxRetransmits}}}async receive({trackId:e,kind:t,rtpParameters:a}){this._assertRecvDirection(),logger.debug("receive() [trackId:%s, kind:%s]",e,t);const r=e,s=t;this._remoteSdp.receive({mid:s,kind:t,offerRtpParameters:a,streamId:a.rtcp.cname,trackId:e});const i={type:"offer",sdp:this._remoteSdp.getSdp()};logger.debug("receive() | calling pc.setRemoteDescription() [offer:%o]",i),await this._pc.setRemoteDescription(i);let n=await this._pc.createAnswer();const c=sdpTransform.parse(n.sdp),o=c.media.find((e=>String(e.mid)===s));sdpCommonUtils.applyCodecParameters({offerRtpParameters:a,answerMediaObject:o}),n={type:"answer",sdp:sdpTransform.write(c)},this._transportReady||await this._setupTransport({localDtlsRole:"client",localSdpObject:c}),logger.debug("receive() | calling pc.setLocalDescription() [answer:%o]",n),await this._pc.setLocalDescription(n);const d=this._pc.getReceivers().find((e=>e.track&&e.track.id===r));if(!d)throw new Error("new RTCRtpReceiver not");return this._mapRecvLocalIdInfo.set(r,{mid:s,rtpParameters:a,rtpReceiver:d}),{localId:r,track:d.track,rtpReceiver:d}}async stopReceiving(e){this._assertRecvDirection(),logger.debug("stopReceiving() [localId:%s]",e);const{mid:t,rtpParameters:a}=this._mapRecvLocalIdInfo.get(e)||{};this._mapRecvLocalIdInfo.delete(e),this._remoteSdp.planBStopReceiving({mid:t,offerRtpParameters:a});const r={type:"offer",sdp:this._remoteSdp.getSdp()};logger.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]",r),await this._pc.setRemoteDescription(r);const s=await this._pc.createAnswer();logger.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]",s),await this._pc.setLocalDescription(s)}async getReceiverStats(e){this._assertRecvDirection();const{rtpReceiver:t}=this._mapRecvLocalIdInfo.get(e)||{};if(!t)throw new Error("associated RTCRtpReceiver not found");return t.getStats()}async receiveDataChannel({sctpStreamParameters:e,label:t,protocol:a}){this._assertRecvDirection();const{streamId:r,ordered:s,maxPacketLifeTime:i,maxRetransmits:n}=e,c={negotiated:!0,id:r,ordered:s,maxPacketLifeTime:i,maxRetransmits:n,protocol:a};logger.debug("receiveDataChannel() [options:%o]",c);const o=this._pc.createDataChannel(t,c);if(!this._hasDataChannelMediaSection){this._remoteSdp.receiveSctpAssociation({oldDataChannelSpec:!0});const e={type:"offer",sdp:this._remoteSdp.getSdp()};logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]",e),await this._pc.setRemoteDescription(e);const t=await this._pc.createAnswer();if(!this._transportReady){const e=sdpTransform.parse(t.sdp);await this._setupTransport({localDtlsRole:"client",localSdpObject:e})}logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]",t),await this._pc.setLocalDescription(t),this._hasDataChannelMediaSection=!0}return{dataChannel:o}}async _setupTransport({localDtlsRole:e,localSdpObject:t}){t||(t=sdpTransform.parse(this._pc.localDescription.sdp));const a=sdpCommonUtils.extractDtlsParameters({sdpObject:t});a.role=e,this._remoteSdp.updateDtlsRole("client"===e?"server":"client"),await this.safeEmitAsPromise("@connect",{dtlsParameters:a}),this._transportReady=!0}_assertSendDirection(){if("send"!==this._direction)throw new Error('method can just be called for handlers with "send" direction')}_assertRecvDirection(){if("recv"!==this._direction)throw new Error('method can just be called for handlers with "recv" direction')}}exports.Safari11=Safari11;
//# sourceMappingURL=/sm/ffe03ea0dc084cfc5083f57065fbac68eeb36ce67221d4641a579ccfdba1ce5a.map