/**
 * Minified by jsDelivr using Terser v5.3.5.
 * Original file: /npm/mediasoup-client@3.6.34/lib/handlers/Chrome67.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(e,t,r,a){void 0===a&&(a=r),Object.defineProperty(e,a,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,a){void 0===a&&(a=r),e[a]=t[r]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),__importStar=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.hasOwnProperty.call(e,r)&&__createBinding(t,e,r);return __setModuleDefault(t,e),t};Object.defineProperty(exports,"__esModule",{value:!0}),exports.Chrome67=void 0;const sdpTransform=__importStar(require("sdp-transform")),Logger_1=require("../Logger"),utils=__importStar(require("../utils")),ortc=__importStar(require("../ortc")),sdpCommonUtils=__importStar(require("./sdp/commonUtils")),sdpPlanBUtils=__importStar(require("./sdp/planBUtils")),HandlerInterface_1=require("./HandlerInterface"),RemoteSdp_1=require("./sdp/RemoteSdp"),logger=new Logger_1.Logger("Chrome67"),SCTP_NUM_STREAMS={OS:1024,MIS:1024};class Chrome67 extends HandlerInterface_1.HandlerInterface{constructor(){super(),this._sendStream=new MediaStream,this._mapSendLocalIdRtpSender=new Map,this._nextSendLocalId=0,this._mapRecvLocalIdInfo=new Map,this._hasDataChannelMediaSection=!1,this._nextSendSctpStreamId=0,this._transportReady=!1}static createFactory(){return()=>new Chrome67}get name(){return"Chrome67"}close(){if(logger.debug("close()"),this._pc)try{this._pc.close()}catch(e){}}async getNativeRtpCapabilities(){logger.debug("getNativeRtpCapabilities()");const e=new RTCPeerConnection({iceServers:[],iceTransportPolicy:"all",bundlePolicy:"max-bundle",rtcpMuxPolicy:"require",sdpSemantics:"plan-b"});try{const t=await e.createOffer({offerToReceiveAudio:!0,offerToReceiveVideo:!0});try{e.close()}catch(e){}const r=sdpTransform.parse(t.sdp);return sdpCommonUtils.extractRtpCapabilities({sdpObject:r})}catch(t){try{e.close()}catch(e){}throw t}}async getNativeSctpCapabilities(){return logger.debug("getNativeSctpCapabilities()"),{numStreams:SCTP_NUM_STREAMS}}run({direction:e,iceParameters:t,iceCandidates:r,dtlsParameters:a,sctpParameters:s,iceServers:i,iceTransportPolicy:n,additionalSettings:o,proprietaryConstraints:c,extendedRtpCapabilities:d}){logger.debug("run()"),this._direction=e,this._remoteSdp=new RemoteSdp_1.RemoteSdp({iceParameters:t,iceCandidates:r,dtlsParameters:a,sctpParameters:s,planB:!0}),this._sendingRtpParametersByKind={audio:ortc.getSendingRtpParameters("audio",d),video:ortc.getSendingRtpParameters("video",d)},this._sendingRemoteRtpParametersByKind={audio:ortc.getSendingRemoteRtpParameters("audio",d),video:ortc.getSendingRemoteRtpParameters("video",d)},this._pc=new RTCPeerConnection(Object.assign({iceServers:i||[],iceTransportPolicy:n||"all",bundlePolicy:"max-bundle",rtcpMuxPolicy:"require",sdpSemantics:"plan-b"},o),c),this._pc.addEventListener("iceconnectionstatechange",(()=>{switch(this._pc.iceConnectionState){case"checking":this.emit("@connectionstatechange","connecting");break;case"connected":case"completed":this.emit("@connectionstatechange","connected");break;case"failed":this.emit("@connectionstatechange","failed");break;case"disconnected":this.emit("@connectionstatechange","disconnected");break;case"closed":this.emit("@connectionstatechange","closed")}}))}async updateIceServers(e){logger.debug("updateIceServers()");const t=this._pc.getConfiguration();t.iceServers=e,this._pc.setConfiguration(t)}async restartIce(e){if(logger.debug("restartIce()"),this._remoteSdp.updateIceParameters(e),this._transportReady)if("send"===this._direction){const e=await this._pc.createOffer({iceRestart:!0});logger.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]",e),await this._pc.setLocalDescription(e);const t={type:"answer",sdp:this._remoteSdp.getSdp()};logger.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]",t),await this._pc.setRemoteDescription(t)}else{const e={type:"offer",sdp:this._remoteSdp.getSdp()};logger.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]",e),await this._pc.setRemoteDescription(e);const t=await this._pc.createAnswer();logger.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]",t),await this._pc.setLocalDescription(t)}}async getTransportStats(){return this._pc.getStats()}async send({track:e,encodings:t,codecOptions:r,codec:a}){this._assertSendDirection(),logger.debug("send() [kind:%s, track.id:%s]",e.kind,e.id),a&&logger.warn("send() | codec selection is not available in %s handler",this.name),this._sendStream.addTrack(e),this._pc.addTrack(e,this._sendStream);let s,i=await this._pc.createOffer(),n=sdpTransform.parse(i.sdp);const o=utils.clone(this._sendingRtpParametersByKind[e.kind],{});o.codecs=ortc.reduceCodecs(o.codecs);const c=utils.clone(this._sendingRemoteRtpParametersByKind[e.kind],{});if(c.codecs=ortc.reduceCodecs(c.codecs),this._transportReady||await this._setupTransport({localDtlsRole:"server",localSdpObject:n}),"video"===e.kind&&t&&t.length>1&&(logger.debug("send() | enabling simulcast"),n=sdpTransform.parse(i.sdp),s=n.media.find((e=>"video"===e.type)),sdpPlanBUtils.addLegacySimulcast({offerMediaObject:s,track:e,numStreams:t.length}),i={type:"offer",sdp:sdpTransform.write(n)}),logger.debug("send() | calling pc.setLocalDescription() [offer:%o]",i),await this._pc.setLocalDescription(i),n=sdpTransform.parse(this._pc.localDescription.sdp),s=n.media.find((t=>t.type===e.kind)),o.rtcp.cname=sdpCommonUtils.getCname({offerMediaObject:s}),o.encodings=sdpPlanBUtils.getRtpEncodings({offerMediaObject:s,track:e}),t)for(let e=0;e<o.encodings.length;++e)t[e]&&Object.assign(o.encodings[e],t[e]);if(o.encodings.length>1&&"video/vp8"===o.codecs[0].mimeType.toLowerCase())for(const e of o.encodings)e.scalabilityMode="S1T3";this._remoteSdp.send({offerMediaObject:s,offerRtpParameters:o,answerRtpParameters:c,codecOptions:r});const d={type:"answer",sdp:this._remoteSdp.getSdp()};logger.debug("send() | calling pc.setRemoteDescription() [answer:%o]",d),await this._pc.setRemoteDescription(d);const p=String(this._nextSendLocalId);this._nextSendLocalId++;const l=this._pc.getSenders().find((t=>t.track===e));return this._mapSendLocalIdRtpSender.set(p,l),{localId:p,rtpParameters:o,rtpSender:l}}async stopSending(e){this._assertSendDirection(),logger.debug("stopSending() [localId:%s]",e);const t=this._mapSendLocalIdRtpSender.get(e);if(!t)throw new Error("associated RTCRtpSender not found");this._pc.removeTrack(t),t.track&&this._sendStream.removeTrack(t.track),this._mapSendLocalIdRtpSender.delete(e);const r=await this._pc.createOffer();logger.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]",r);try{await this._pc.setLocalDescription(r)}catch(e){if(0===this._sendStream.getTracks().length)return void logger.warn("stopSending() | ignoring expected error due no sending tracks: %s",e.toString());throw e}if("stable"===this._pc.signalingState)return;const a={type:"answer",sdp:this._remoteSdp.getSdp()};logger.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]",a),await this._pc.setRemoteDescription(a)}async replaceTrack(e,t){this._assertSendDirection(),t?logger.debug("replaceTrack() [localId:%s, track.id:%s]",e,t.id):logger.debug("replaceTrack() [localId:%s, no track]",e);const r=this._mapSendLocalIdRtpSender.get(e);if(!r)throw new Error("associated RTCRtpSender not found");const a=r.track;await r.replaceTrack(t),a&&this._sendStream.removeTrack(a),t&&this._sendStream.addTrack(t)}async setMaxSpatialLayer(e,t){this._assertSendDirection(),logger.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]",e,t);const r=this._mapSendLocalIdRtpSender.get(e);if(!r)throw new Error("associated RTCRtpSender not found");const a=r.getParameters();a.encodings.forEach(((e,r)=>{e.active=r<=t})),await r.setParameters(a)}async setRtpEncodingParameters(e,t){this._assertSendDirection(),logger.debug("setRtpEncodingParameters() [localId:%s, params:%o]",e,t);const r=this._mapSendLocalIdRtpSender.get(e);if(!r)throw new Error("associated RTCRtpSender not found");const a=r.getParameters();a.encodings.forEach(((e,r)=>{a.encodings[r]=Object.assign(Object.assign({},e),t)})),await r.setParameters(a)}async getSenderStats(e){this._assertSendDirection();const t=this._mapSendLocalIdRtpSender.get(e);if(!t)throw new Error("associated RTCRtpSender not found");return t.getStats()}async sendDataChannel({ordered:e,maxPacketLifeTime:t,maxRetransmits:r,label:a,protocol:s}){this._assertSendDirection();const i={negotiated:!0,id:this._nextSendSctpStreamId,ordered:e,maxPacketLifeTime:t,maxRetransmitTime:t,maxRetransmits:r,protocol:s};logger.debug("sendDataChannel() [options:%o]",i);const n=this._pc.createDataChannel(a,i);if(this._nextSendSctpStreamId=++this._nextSendSctpStreamId%SCTP_NUM_STREAMS.MIS,!this._hasDataChannelMediaSection){const e=await this._pc.createOffer(),t=sdpTransform.parse(e.sdp),r=t.media.find((e=>"application"===e.type));this._transportReady||await this._setupTransport({localDtlsRole:"server",localSdpObject:t}),logger.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]",e),await this._pc.setLocalDescription(e),this._remoteSdp.sendSctpAssociation({offerMediaObject:r});const a={type:"answer",sdp:this._remoteSdp.getSdp()};logger.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]",a),await this._pc.setRemoteDescription(a),this._hasDataChannelMediaSection=!0}return{dataChannel:n,sctpStreamParameters:{streamId:i.id,ordered:i.ordered,maxPacketLifeTime:i.maxPacketLifeTime,maxRetransmits:i.maxRetransmits}}}async receive({trackId:e,kind:t,rtpParameters:r}){this._assertRecvDirection(),logger.debug("receive() [trackId:%s, kind:%s]",e,t);const a=e,s=t;this._remoteSdp.receive({mid:s,kind:t,offerRtpParameters:r,streamId:r.rtcp.cname,trackId:e});const i={type:"offer",sdp:this._remoteSdp.getSdp()};logger.debug("receive() | calling pc.setRemoteDescription() [offer:%o]",i),await this._pc.setRemoteDescription(i);let n=await this._pc.createAnswer();const o=sdpTransform.parse(n.sdp),c=o.media.find((e=>String(e.mid)===s));sdpCommonUtils.applyCodecParameters({offerRtpParameters:r,answerMediaObject:c}),n={type:"answer",sdp:sdpTransform.write(o)},this._transportReady||await this._setupTransport({localDtlsRole:"client",localSdpObject:o}),logger.debug("receive() | calling pc.setLocalDescription() [answer:%o]",n),await this._pc.setLocalDescription(n);const d=this._pc.getReceivers().find((e=>e.track&&e.track.id===a));if(!d)throw new Error("new RTCRtpReceiver not");return this._mapRecvLocalIdInfo.set(a,{mid:s,rtpParameters:r,rtpReceiver:d}),{localId:a,track:d.track,rtpReceiver:d}}async stopReceiving(e){this._assertRecvDirection(),logger.debug("stopReceiving() [localId:%s]",e);const{mid:t,rtpParameters:r}=this._mapRecvLocalIdInfo.get(e)||{};this._mapRecvLocalIdInfo.delete(e),this._remoteSdp.planBStopReceiving({mid:t,offerRtpParameters:r});const a={type:"offer",sdp:this._remoteSdp.getSdp()};logger.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]",a),await this._pc.setRemoteDescription(a);const s=await this._pc.createAnswer();logger.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]",s),await this._pc.setLocalDescription(s)}async getReceiverStats(e){this._assertRecvDirection();const{rtpReceiver:t}=this._mapRecvLocalIdInfo.get(e)||{};if(!t)throw new Error("associated RTCRtpReceiver not found");return t.getStats()}async receiveDataChannel({sctpStreamParameters:e,label:t,protocol:r}){this._assertRecvDirection();const{streamId:a,ordered:s,maxPacketLifeTime:i,maxRetransmits:n}=e,o={negotiated:!0,id:a,ordered:s,maxPacketLifeTime:i,maxRetransmitTime:i,maxRetransmits:n,protocol:r};logger.debug("receiveDataChannel() [options:%o]",o);const c=this._pc.createDataChannel(t,o);if(!this._hasDataChannelMediaSection){this._remoteSdp.receiveSctpAssociation({oldDataChannelSpec:!0});const e={type:"offer",sdp:this._remoteSdp.getSdp()};logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]",e),await this._pc.setRemoteDescription(e);const t=await this._pc.createAnswer();if(!this._transportReady){const e=sdpTransform.parse(t.sdp);await this._setupTransport({localDtlsRole:"client",localSdpObject:e})}logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]",t),await this._pc.setLocalDescription(t),this._hasDataChannelMediaSection=!0}return{dataChannel:c}}async _setupTransport({localDtlsRole:e,localSdpObject:t}){t||(t=sdpTransform.parse(this._pc.localDescription.sdp));const r=sdpCommonUtils.extractDtlsParameters({sdpObject:t});r.role=e,this._remoteSdp.updateDtlsRole("client"===e?"server":"client"),await this.safeEmitAsPromise("@connect",{dtlsParameters:r}),this._transportReady=!0}_assertSendDirection(){if("send"!==this._direction)throw new Error('method can just be called for handlers with "send" direction')}_assertRecvDirection(){if("recv"!==this._direction)throw new Error('method can just be called for handlers with "recv" direction')}}exports.Chrome67=Chrome67;
//# sourceMappingURL=/sm/f700788ec1df08abe4006551799ded3db43beaea3d992581c25e9fc0dde114ae.map